from typing import Any, Annotated

from agent_framework import ChatAgent, ai_function
from pydantic import BaseModel, ConfigDict, Field, computed_field

from agents.base import chat_client


@ai_function
def prepare_sku_candidates(payload: dict[str, Any], top_k: int = 5) -> dict[str, Any]:
    """Return placeholder SKU candidates for each order line."""
    order = payload.get("purchase_order", {})
    lines = order.get("order_lines", [])
    return {
        "purchase_order": order,
        "line_candidates": [
            {
                "line_index": idx,
                "candidates": [
                    {
                        "sku": f"SKU-{idx}-{i}",
                        "title": f"Candidate {i}",
                        "description": "Placeholder candidate generated by prepare_sku_candidates.",
                        "similarity_score": max(0.1, 1.0 - 0.1 * i),
                    }
                    for i in range(min(top_k, 3))
                ],
            }
            for idx, _ in enumerate(lines)
        ],
    }


@ai_function
def check_credit(customer_name: str, order_total: float) -> dict[str, Any]:
    """Mock credit check against static limits."""
    credit_limit = 10000.0
    open_ar = 2500.0
    available_credit = credit_limit - open_ar
    approved = order_total <= available_credit
    return {
        "customer_name": customer_name,
        "order_total": order_total,
        "credit_limit": credit_limit,
        "open_ar": open_ar,
        "available_credit": max(0.0, available_credit - order_total),
        "approved": approved,
        "reason": "Within credit limits" if approved else "Exceeds available credit",
    }


class ResolvedItem(BaseModel):
    model_config = ConfigDict(extra="forbid")
    matched_customer_id: Annotated[
        str,
        Field(
            description="Resolved customer identifier from CRM (Customers)",
        ),
    ]
    matched_customer_name: Annotated[
        str,
        Field(
            description="Resolved customer name from CRM (Customers)",
        ),
    ]
    matched_customer_address: Annotated[
        str,
        Field(
            description="Resolved customer address from CRM (Customers)",
        ),
    ]
    matched_product_sku: Annotated[
        str,
        Field(
            description="Matched product SKU identifier from catalog (Products) "
            "through similarity search",
        ),
    ]
    matched_product_name: Annotated[
        str,
        Field(
            description="Matched product name or title from catalog (Products) "
            "through similarity search",
        )
    ]
    ordered_qty: Annotated[
        int,
        Field(
            gt=0,
            strict=True,
            description="Quantity ordered",
        ),
    ]
    price: Annotated[
        float,
        Field(
            ge=0,
            strict=True,
            description="Unit price in EUR",
        ),
    ]
    vat_rate: Annotated[
        float,
        Field(
            default=0.19,
            description="VAT rate (default 19% for Germany)",
        ),
    ]
    product_availability: Annotated[
        bool,
        Field(
            description="Whether the item is in stock and available: "
            "True only if Qty Available >= ordered_qty",
        ),
    ]

    @computed_field
    @property
    def line_item_subtotal(self) -> Annotated[
        float,
        Field(
            description="Line item subtotal for each SKU (ordered_qty * price)",
        ),
    ]:
        return self.ordered_qty * self.price


class ResolvedPO(BaseModel):
    model_config = ConfigDict(extra="forbid")
    email_id: Annotated[str, Field(
        description="Gmail message ID of the original purchase order email")]
    customer_id: Annotated[str, Field(
        description="Customer identifier or account number")]
    customer_name: Annotated[str, Field(
        description="Customer's business or contact name")]
    customer_credit_ok: Annotated[bool, Field(
        description="Whether customer has sufficient credit to fulfill this order")]
    items: Annotated[list[ResolvedItem], Field(
        description="list of resolved order line items")]

    @computed_field
    @property
    def tax(self) -> Annotated[
        float,
        Field(
            ge=0,
            strict=True,
            description="Calculated sales tax (sum of line subtotal * VAT rate)",
        ),
    ]:
        return sum(item.line_item_subtotal * item.vat_rate for item in self.items)

    @computed_field
    @property
    def shipping(self) -> Annotated[
            float,
            Field(ge=0, strict=True,
                  description="Flat shipping fee (€25 if subtotal > 0)")]:
        return 25.0 if self.subtotal > 0 else 0.0

    @computed_field
    @property
    def subtotal(self) -> Annotated[float, Field(ge=0, strict=True,
                                                 description="Subtotal of all line items before tax and shipping")]:
        return sum(item.line_item_subtotal for item in self.items)

    @computed_field
    @property
    def order_total(self) -> Annotated[float, Field(ge=0, strict=True, description="Final total: subtotal + tax + shipping")]:
        return self.subtotal + self.tax + self.shipping


resolver = ChatAgent(
    chat_client=chat_client,
    name="resolver",
    instructions=(
        "Resolve the ParsedPO against search and CRM. "
        "For each line item, find the SKU, name, unit price, VAT rate, and "
        "availability. Resolve or create the customer. Call check_credit with "
        "the order total you compute from the resolved line subtotals, VAT, "
        "and flat shipping (€25 whenever the subtotal is positive). "
        "Return a ResolvedPO JSON with the customer fields and "
        "resolved items only; tax, shipping, subtotal, and "
        "total are computed automatically."
    ),
    tools=[
        check_credit,
    ],
    response_format=ResolvedPO,
)
